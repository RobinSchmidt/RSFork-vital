Vital seems to optionally use the Intel Performance Primitives (IPP) library for the FFT with an
option to fall back to KissFFT when IPP is not available. So, to build Vital, one must either 
install the IPP library or tweak the compilation settings in the .jucer file to set some INTEL_IPP=1 
preprocessor macro to INTEL_IPP=0 and then re-generate the project files for all the IDEs like 
Visual Studio etc. Installers (online and offline) for IPP can be obtained from here:

  https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#ipp

The offline installer for Windows will by default install the IPP into:

  C:\Program Files (x86)\Intel\oneAPI

It says so on the installer page where one may or may not consent to the collection of information 
in the bottom left corner where it says: "Installation Location".

After installing IPP, double-click on (in e.g. Windows Explorer):

  standalone/builds/vs19/Vial.sln

to fire up Visual Studio 2019 with the Vial solution (yeah - I guess that was a typo?). The solution 
contains one project called Vial_App. Trying to build it did *not* succeed out of the box. The 
compiler complained with the error message:

  Cannot open include file: 'ipps.h'

Apparently, the compiler doesn't know the include path for the header file. After installing IPP, it 
is located in:

  C:\Program Files (x86)\Intel\oneAPI\ipp\2021.10\include\ipp

on my machine. This path must be added to the compiler search paths. This can be done in the jucer 
file (which requires re-generating the IDE project files) or directly in Visual Studio like so:

  right-click on Vial_App -> Properties -> C/C++ -> General -> Additional Include Directories

before navigating there, make sure to have "Configuration: All Configurations" selected in the top 
left. Click on the button that appears to the right of the line, go to "Edit". Add a new line at the 
bottom with the path given above. This should fix the compiler error but now we get linker errors of 
the kind:

  unresolved external symbol

related to IPP functions. Apparently, the linker doesn't know where to find the precompiled library 
files for IPP. They are located in:

  C:\Program Files (x86)\Intel\oneAPI\ipp\2021.10\lib

This path must be added to the linker search paths via navigating to:

  right-click on Vial_App -> Properties -> Linker -> General -> Additional Library Directories

again making sure that "Configuration: All Configurations" is selected. We need to also go to:

  ...                                      Linker -> Input -> Additional Dependencies

and add the line:

  ipps.lib

there. Now the project compiles an links. But when trying to start Vital, an error message pops up 
that says:

  ...ipps.dll was not found...  

This file is located in:

  C:\Program Files (x86)\Intel\oneAPI\ipp\2021.10\bin

Placing a copy next to the executable Vial.exe does *not* solve it. We seem to also need: 

  ippcore.dll

After copying that file into the directory of Vial.exe, too, we get the following message that says 
some more dlls are needed - some of them apparently optional:

  ippsl9.dll (the most suitable for your CPU)
  ippse9.dll (optional), 
  ippsy8.dll (optional), 
  ippsn8.dll (optional), 
  ippsm7.dll (optional)

They can all be found in the same folder as ipps.dll. I copied them all over into the directory 
where vial.exe resides. Now it seems to be possible to run the standalone version. ...But it is not
really playable. It apparently immediately fries the CPU even with the simple sawtooth init patch.
The standalone version seems to be a sort of real standalone version as opposed to the 
"standalone-plugin" versions that can be built from the

  plugin/builds/...

versions. It doesn't have the additional "Options" button that is provided by juce for the 
"standalone-plugin" version.

Seeing that the debug build apparently has CPU performance problems, let's try to build it in the
"Release" configuration instead. ...the release version does not build at all - it complains about 
things related to "firebase"


...puuhh...this is really fiddly and frustrating... I need a break....TBC...





----------------------------------------------------------------------------------------------------
Let's try to tweak the Debug version, which does compile, to include optimizations:

Change

  right-click on Vial_App -> Properties -> C/C++ -> General -> Debug Information Format

from "Program Database (/Zi)" to "None" and

  right-click on Vial_App -> Properties -> C/C++ -> Optimization -> Optimization

from "Disabled (/Od)" to "Maximum Optimization (Favor Speed) (/O2)". That should turn it basically 
into a "Release" configuration with respect to performance. When doing this and build and run it,
we get a warning window saying:

  "Assertion failed ... utils::isFinite(processor->output()->....) "

and the drawing of ENV1 looks messed up. Trying "Optimizations (Favor Speed) (/Ox)" results in the 
same behavior. Let's see, if we can disable the assertions. Try:

  right-click on Vial_App -> Properties -> C/C++ -> Preprocessor Definitions

and set DEBUG=0 and _DEBUG=0 (from DEBUG and _DEBUG). Aha - now the assertions disappear. But the 
messed up envelope drawing remains...there is a click on strat up and then no sound...and when 
closing it, we get an access violation. OK - I have reverted these changes in the project via git 
again. Maybe I should create a new build configuration myself...but maybe not in VS but in Projucer.

OK - let's try something else. Maybe the CPU frying is due to ceratin assertions that happen in the 
debug build? It seems like VITAL_ASSERT( vital::utils::isFinite(...) ) is used a lot in assertions. 
The implementation of isFinite is in poly_utils.h, line 420 and the VITAL_ASSERT macro is defined in 
common.h, line 22ff. Replacing the VITAL_ASSERT macro by an empty macro does indeed help to lower 
the CPU usage - but it's still not playable. ...aand we get an access violation on closing it.


----------------------------------------------------------------------------------------------------
Questions:

-What is this "firebase" stuff about? It's a precompiled third party library that the project links
 to. There are some compiler flags in the .jucer file that seem to be able to switch off using that
 library.  ->  Figure that out!


...TBC...

